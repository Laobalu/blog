>js是单线程语言，意味着所有任务都要排队，而浏览器为了避免阻塞的发生，加入了事件循环机制来处理异步任务。

## 事件循环  
所有任务可分为两种，同步任务以及异步任务。 浏览器包含执行栈和任务队列。  
1. 同步任务都在主线程上执行，形成一个执行栈。
2. 浏览器内核解析到dom binding、timer、network等异步webAPI时，会交由浏览器内核其他模块处理。当异步任务完成，其回调函数会被推入任务队列中。
3. 当执行栈中同步任务执行完，会将任务队列中的回调函数推入执行栈，再依次执行。
4. 循环1-3步，直到执行栈和任务队列都为空。  

## 任务队列    
> 任务队列分为宏任务队列和微任务队列，来处理不同api的回调函数。
### 宏任务macro-task
- script整体代码
- `setTimeout`
- `setInterval`
- `setImmediate(node.js)`
- `I/O`
- `UI rendering`。

事件循环时，执行栈中的任务就是宏任务，包括每次从任务队列中将事件回调推入到执行栈中。

### 微任务micro-task
- `Process.nextTick()`
- `Promise.then()`
- `Object.observe()`
- `mutation.observe()`

宏任务包含微任务，可以看为另一个任务队列，当执行栈结束后，会立即执行微任务。

### 宏任务和微任务执行顺序
1. 浏览器先执行在执行栈中的宏任务，当执行栈清空后，会将微任务推入执行栈，执行所有微任务。
2. 所有微任务执行完后，再从任务队列推入任务到执行栈，新的一轮循环又开始执行。  

![事件循环_01](../images/事件循环_01.png)

## 页面更新渲染
宏任务执行完会立即执行当前微任务队列中的任务，当微任务执行完，gui线程会接管，渲染dom，渲染完成后，js线程继续接管，开始下一个宏任务。    


- 在一轮event loop中多次修改同一dom，只有最后一次会进行绘制。
- 渲染更新（Update the rendering）会在event loop中的tasks和microtasks完成后进行，但并不是每轮event loop都会更新渲染，这取决于是否修改了dom和浏览器觉得是否有必要在此时立即将新状态呈现给用户。 如果在一帧的时间内（时间并不确定，因为浏览器每秒的帧数总在波动，16.7ms只是估算并不准确）修改了多处dom，浏览器可能将变动积攒起来，只进行一次绘制，这是合理的。
- 如果希望在每轮event loop都即时呈现变动，可以使用requestAnimationFrame。

## 案例
```js
setTimeout(() => console.log('timeout'))

Promise.resolve().then(() => {
    console.log('promise1')
    Promise.resolve().then(() => console.log('promise2')).then(() => console.log('aaa'))
    Promise.resolve().then(() => console.log('promise3'))
}).then(() => console.log('promise4'))

console.log('normal')  
```
输出
```js
normal
promise1
promise2
promise3
promise4
aaa
timeout
```
promise4所在函数，比aaa所在函数更早进入微任务队列。